# Simple Billing Service for OKE (no Stripe, uses local DB)
apiVersion: v1
kind: ConfigMap
metadata:
  name: billing-config
  namespace: temporal-cloud
data:
  DATABASE_URL: "postgres://temporal:temporal123@postgres.temporal-cloud.svc.cluster.local:5432/billing?sslmode=disable"
  ENABLE_AUTH: "false"
  PORT: "8082"
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: billing-service
  namespace: temporal-cloud
spec:
  replicas: 1
  selector:
    matchLabels:
      app: billing-service
  template:
    metadata:
      labels:
        app: billing-service
    spec:
      initContainers:
        # Build and run billing service from source
        - name: build-billing
          image: golang:1.22-alpine
          command:
            - sh
            - -c
            - |
              apk add --no-cache git
              cd /app
              git clone --depth 1 https://github.com/temporalio/temporal-cloud-offering.git || true
              cd temporal-cloud-offering/billing-service || cd /app
              # If git fails, create a minimal billing service
              if [ ! -f main.go ]; then
                cat > main.go << 'GOEOF'
              package main

              import (
                "context"
                "encoding/json"
                "fmt"
                "log"
                "net/http"
                "os"
                "time"

                "github.com/gorilla/mux"
                "github.com/jackc/pgx/v5/pgxpool"
              )

              type Subscription struct {
                Plan              string  `json:"plan"`
                Status            string  `json:"status"`
                ActionsIncluded   int64   `json:"actions_included"`
                ActiveStorageGB   float64 `json:"active_storage_gb"`
                RetainedStorageGB float64 `json:"retained_storage_gb"`
              }

              type UsageSummary struct {
                TotalActions       int64   `json:"total_actions"`
                ActiveStorageGBH   float64 `json:"active_storage_gbh"`
                RetainedStorageGBH float64 `json:"retained_storage_gbh"`
                EstimatedCostCents int64   `json:"estimated_cost_cents"`
              }

              type Namespace struct {
                ID                string    `json:"id"`
                Name              string    `json:"name"`
                TemporalNamespace string    `json:"temporal_namespace"`
                Region            string    `json:"region"`
                Status            string    `json:"status"`
                RetentionDays     int       `json:"retention_days"`
                CreatedAt         time.Time `json:"created_at"`
              }

              var db *pgxpool.Pool

              func main() {
                var err error
                db, err = pgxpool.New(context.Background(), os.Getenv("DATABASE_URL"))
                if err != nil {
                  log.Fatal(err)
                }
                defer db.Close()

                r := mux.NewRouter()
                r.Use(corsMiddleware)
                r.HandleFunc("/health", healthHandler).Methods("GET")
                r.HandleFunc("/api/v1/organizations/{id}/subscription", getSubscription).Methods("GET")
                r.HandleFunc("/api/v1/organizations/{id}/usage/current", getUsage).Methods("GET")
                r.HandleFunc("/api/v1/organizations/{id}/namespaces", getNamespaces).Methods("GET")
                r.HandleFunc("/api/v1/organizations/{id}/invoices", getInvoices).Methods("GET")

                port := os.Getenv("PORT")
                if port == "" {
                  port = "8082"
                }
                log.Printf("Billing service starting on port %s", port)
                log.Fatal(http.ListenAndServe(":"+port, r))
              }

              func corsMiddleware(next http.Handler) http.Handler {
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
                  w.Header().Set("Access-Control-Allow-Origin", "*")
                  w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
                  w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")
                  if r.Method == "OPTIONS" {
                    w.WriteHeader(http.StatusOK)
                    return
                  }
                  next.ServeHTTP(w, r)
                })
              }

              func healthHandler(w http.ResponseWriter, r *http.Request) {
                w.Header().Set("Content-Type", "application/json")
                json.NewEncoder(w).Encode(map[string]string{"status": "ok", "service": "billing"})
              }

              func getSubscription(w http.ResponseWriter, r *http.Request) {
                vars := mux.Vars(r)
                orgID := vars["id"]
                
                var sub Subscription
                err := db.QueryRow(context.Background(),
                  `SELECT plan, status, actions_included, active_storage_gb, retained_storage_gb 
                   FROM subscriptions WHERE organization_id = $1`, orgID).Scan(
                  &sub.Plan, &sub.Status, &sub.ActionsIncluded, &sub.ActiveStorageGB, &sub.RetainedStorageGB)
                if err != nil {
                  http.Error(w, `{"error": "Subscription not found"}`, http.StatusNotFound)
                  return
                }
                w.Header().Set("Content-Type", "application/json")
                json.NewEncoder(w).Encode(sub)
              }

              func getUsage(w http.ResponseWriter, r *http.Request) {
                vars := mux.Vars(r)
                orgID := vars["id"]
                
                var usage UsageSummary
                err := db.QueryRow(context.Background(),
                  `SELECT total_actions, active_storage_gbh, retained_storage_gbh, estimated_cost_cents 
                   FROM usage_records WHERE organization_id = $1 ORDER BY period_start DESC LIMIT 1`, orgID).Scan(
                  &usage.TotalActions, &usage.ActiveStorageGBH, &usage.RetainedStorageGBH, &usage.EstimatedCostCents)
                if err != nil {
                  usage = UsageSummary{TotalActions: 0, ActiveStorageGBH: 0, RetainedStorageGBH: 0, EstimatedCostCents: 0}
                }
                w.Header().Set("Content-Type", "application/json")
                json.NewEncoder(w).Encode(usage)
              }

              func getNamespaces(w http.ResponseWriter, r *http.Request) {
                vars := mux.Vars(r)
                orgID := vars["id"]
                
                rows, err := db.Query(context.Background(),
                  `SELECT id, name, temporal_namespace, region, status, retention_days, created_at 
                   FROM namespaces WHERE organization_id = $1`, orgID)
                if err != nil {
                  w.Header().Set("Content-Type", "application/json")
                  json.NewEncoder(w).Encode([]Namespace{})
                  return
                }
                defer rows.Close()
                
                var namespaces []Namespace
                for rows.Next() {
                  var ns Namespace
                  rows.Scan(&ns.ID, &ns.Name, &ns.TemporalNamespace, &ns.Region, &ns.Status, &ns.RetentionDays, &ns.CreatedAt)
                  namespaces = append(namespaces, ns)
                }
                if namespaces == nil {
                  namespaces = []Namespace{}
                }
                w.Header().Set("Content-Type", "application/json")
                json.NewEncoder(w).Encode(namespaces)
              }

              func getInvoices(w http.ResponseWriter, r *http.Request) {
                w.Header().Set("Content-Type", "application/json")
                json.NewEncoder(w).Encode([]interface{}{})
              }
              GOEOF
                cat > go.mod << 'MODEOF'
              module billing-service
              go 1.22
              require (
                github.com/gorilla/mux v1.8.1
                github.com/jackc/pgx/v5 v5.5.0
              )
              MODEOF
                go mod tidy
              fi
              CGO_ENABLED=0 GOOS=linux go build -o /shared/billing-service .
          volumeMounts:
            - name: shared
              mountPath: /shared
      containers:
        - name: billing
          image: alpine:latest
          command: ["/shared/billing-service"]
          ports:
            - containerPort: 8082
          envFrom:
            - configMapRef:
                name: billing-config
          volumeMounts:
            - name: shared
              mountPath: /shared
          resources:
            requests:
              memory: "64Mi"
              cpu: "50m"
            limits:
              memory: "256Mi"
              cpu: "500m"
      volumes:
        - name: shared
          emptyDir: {}
---
apiVersion: v1
kind: Service
metadata:
  name: billing-service
  namespace: temporal-cloud
spec:
  type: NodePort
  selector:
    app: billing-service
  ports:
    - port: 8082
      targetPort: 8082
      nodePort: 30082
